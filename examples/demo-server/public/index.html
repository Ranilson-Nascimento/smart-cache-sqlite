<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>smart-cache-sqlite • Exemplos de Uso</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f8fafc;
      min-height: 100vh;
      color: #1f2937;
      line-height: 1.6;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
    }
    h1 {
      margin: 0 0 10px 0;
      color: #1f2937;
      font-size: 2.5em;
      font-weight: 700;
      text-align: center;
    }
    .subtitle {
      color: #6b7280;
      margin-bottom: 40px;
      font-size: 1.2em;
      text-align: center;
    }
    .section {
      margin-bottom: 40px;
      padding: 30px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .section h2 {
      margin: 0 0 20px 0;
      color: #1f2937;
      font-size: 1.8em;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 10px;
    }
    .section h3 {
      margin: 30px 0 15px 0;
      color: #374151;
      font-size: 1.4em;
    }
    .code-block {
      background: #1f2937;
      color: #e5e7eb;
      padding: 20px;
      border-radius: 8px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 14px;
      margin: 20px 0;
      overflow-x: auto;
      border: 1px solid #374151;
    }
    .code-block .comment {
      color: #6b7280;
    }
    .code-block .keyword {
      color: #60a5fa;
    }
    .code-block .string {
      color: #34d399;
    }
    .code-block .function {
      color: #fbbf24;
    }
    .example {
      background: #f0f9ff;
      border: 1px solid #0ea5e9;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
    }
    .example h4 {
      margin: 0 0 15px 0;
      color: #0c4a6e;
      font-size: 1.2em;
    }
    .feature-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    .feature-item {
      background: #f8fafc;
      padding: 20px;
      border-radius: 8px;
      border-left: 4px solid #3b82f6;
    }
    .feature-item h4 {
      margin: 0 0 10px 0;
      color: #1f2937;
    }
    .feature-item p {
      margin: 0;
      color: #6b7280;
      font-size: 0.95em;
    }
    .strategy-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    .strategy-card {
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      padding: 20px;
      transition: all 0.3s ease;
    }
    .strategy-card:hover {
      border-color: #3b82f6;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.1);
    }
    .strategy-card h4 {
      margin: 0 0 10px 0;
      color: #1f2937;
    }
    .strategy-card p {
      margin: 0;
      color: #6b7280;
      font-size: 0.9em;
    }
    .btn {
      display: inline-block;
      padding: 12px 24px;
      background: #3b82f6;
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-weight: 500;
      margin: 10px 10px 10px 0;
      transition: background 0.3s ease;
    }
    .btn:hover {
      background: #2563eb;
    }
    .btn.secondary {
      background: #6b7280;
    }
    .btn.secondary:hover {
      background: #4b5563;
    }
    .note {
      background: #fef3c7;
      border: 1px solid #f59e0b;
      border-radius: 6px;
      padding: 15px;
      margin: 20px 0;
    }
    .note p {
      margin: 0;
      color: #92400e;
    }
    .highlight {
      background: #dbeafe;
      border-left: 4px solid #3b82f6;
      padding: 15px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>smart-cache-sqlite</h1>
    <p class="subtitle">Cache inteligente para SQLite com TTL, LRU e estrategias avancadas de invalidacao</p>

    <div class="section">
      <h2>O que e smart-cache-sqlite?</h2>
      <p>O smart-cache-sqlite e uma biblioteca que adiciona uma camada de cache inteligente sobre bancos de dados SQLite. Ela combina estrategias de cache modernas com invalidacao automatica baseada nas mudancas do banco de dados.</p>

      <div class="feature-list">
        <div class="feature-item">
          <h4>Cache com TTL e LRU</h4>
          <p>Gerenciamento automatico de memoria usando Time-To-Live e Least Recently Used para otimizar performance.</p>
        </div>
        <div class="feature-item">
          <h4>Tres Estrategias de Cache</h4>
          <p>Cache-First, Network-First e Stale-While-Revalidate para diferentes necessidades de dados.</p>
        </div>
        <div class="feature-item">
          <h4>Invalidacao Automatica</h4>
          <p>Detecta mudancas no banco usando PRAGMA data_version do SQLite, sem necessidade de triggers manuais.</p>
        </div>
        <div class="feature-item">
          <h4>Telemetria Detalhada</h4>
          <p>Estatisticas completas de performance, hit rates e uso de memoria para monitoramento.</p>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Instalacao</h2>
      <div class="code-block">npm install smart-cache-sqlite better-sqlite3</div>
      <p>Ou para projetos que usam sqlite3 assincrono:</p>
      <div class="code-block">npm install smart-cache-sqlite sqlite3</div>
    </div>

    <div class="section">
      <h2>Exemplo Basico</h2>
      <p>Veja como e simples usar o smart-cache-sqlite em seu projeto:</p>

      <div class="code-block"><span class="keyword">import</span> { SmartCache } <span class="keyword">from</span> <span class="string">'smart-cache-sqlite'</span>;
<span class="keyword">import</span> Database <span class="keyword">from</span> <span class="string">'better-sqlite3'</span>;

<span class="comment">// Criar conexao com o banco</span>
<span class="keyword">const</span> db = <span class="keyword">new</span> <span class="function">Database</span>(<span class="string">'meu_banco.db'</span>);

<span class="comment">// Criar instancia do cache</span>
<span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="function">SmartCache</span>(db, {
  maxItems: <span class="string">1000</span>,
  ttlMs: <span class="string">5 * 60 * 1000</span>, <span class="comment">// 5 minutos</span>
  strategy: <span class="string">'cache-first'</span>
});

<span class="comment">// Usar o cache para executar queries</span>
<span class="keyword">const</span> usuarios = cache.<span class="function">query</span>(<span class="string">'SELECT * FROM usuarios WHERE cidade = ?'</span>, [<span class="string">'Sao Paulo'</span>]);
console.<span class="function">log</span>(usuarios);</div>

      <div class="note">
        <p><strong>Nota:</strong> O cache detecta automaticamente quando o banco de dados muda e invalida as entradas afetadas.</p>
      </div>
    </div>

    <div class="section">
      <h2>Estrategias de Cache</h2>
      <p>O smart-cache-sqlite oferece tres estrategias diferentes para diferentes tipos de dados:</p>

      <div class="strategy-grid">
        <div class="strategy-card">
          <h4>Cache-First</h4>
          <p>Sempre tenta servir dados do cache primeiro. Se nao encontrar ou estiver expirado, busca no banco e armazena no cache. Ideal para dados que nao mudam frequentemente.</p>
        </div>
        <div class="strategy-card">
          <h4>Network-First</h4>
          <p>Sempre busca no banco primeiro, depois armazena no cache. Util para dados criticos que precisam estar sempre atualizados.</p>
        </div>
        <div class="strategy-card">
          <h4>Stale-While-Revalidate</h4>
          <p>Serve dados do cache imediatamente (mesmo se velhos), mas revalida em background para a proxima requisicao. Oferece a melhor experiencia do usuario.</p>
        </div>
      </div>

      <h3>Exemplo: Configurando Estrategias</h3>
      <div class="code-block"><span class="comment">// Cache-First para dados estaticos</span>
<span class="keyword">const</span> cacheEstatico = <span class="keyword">new</span> <span class="function">SmartCache</span>(db, {
  strategy: <span class="string">'cache-first'</span>,
  ttlMs: <span class="string">10 * 60 * 1000</span> <span class="comment">// 10 minutos</span>
});

<span class="comment">// Network-First para dados criticos</span>
<span class="keyword">const</span> cacheCritico = <span class="keyword">new</span> <span class="function">SmartCache</span>(db, {
  strategy: <span class="string">'network-first'</span>,
  ttlMs: <span class="string">60 * 1000</span> <span class="comment">// 1 minuto</span>
});

<span class="comment">// Stale-While-Revalidate para melhor UX</span>
<span class="keyword">const</span> cacheUX = <span class="keyword">new</span> <span class="function">SmartCache</span>(db, {
  strategy: <span class="string">'stale-while-revalidate'</span>,
  ttlMs: <span class="string">5 * 60 * 1000</span> <span class="comment">// 5 minutos</span>
});</div>
    </div>

    <div class="section">
      <h2>Exemplos Avancados</h2>

      <h3>Queries Complexas com JOIN</h3>
      <div class="example">
        <h4>Busca de pedidos com informacoes do cliente</h4>
        <div class="code-block"><span class="keyword">const</span> pedidosComCliente = cache.<span class="function">query</span>(`
  <span class="keyword">SELECT</span> p.id, p.total, p.data_pedido,
         c.nome <span class="keyword">as</span> cliente_nome, c.email
  <span class="keyword">FROM</span> pedidos p
  <span class="keyword">JOIN</span> clientes c <span class="keyword">ON</span> p.cliente_id = c.id
  <span class="keyword">WHERE</span> p.status = ?
  <span class="keyword">ORDER BY</span> p.data_pedido <span class="keyword">DESC</span>
  <span class="keyword">LIMIT</span> ?
`, [<span class="string">'pendente'</span>, <span class="string">50</span>]);</div>
        <p>O cache automaticamente identifica que esta query envolve as tabelas 'pedidos' e 'clientes', e ira invalidar o cache quando qualquer dessas tabelas for modificada.</p>
      </div>

      <h3>Estatisticas e Monitoramento</h3>
      <div class="example">
        <h4>Acompanhando performance do cache</h4>
        <div class="code-block"><span class="comment">// Obter estatisticas detalhadas</span>
<span class="keyword">const</span> stats = cache.<span class="function">stats</span>();
console.<span class="function">log</span>(<span class="string">'Taxa de acerto:'</span>, stats.hitRate);
console.<span class="function">log</span>(<span class="string">'Total de consultas:'</span>, stats.totalQueries);
console.<span class="function">log</span>(<span class="string">'Itens em cache:'</span>, stats.totalItems);

<span class="comment">// Exemplo de output:</span>
<span class="comment">// Taxa de acerto: 0.85 (85%)</span>
<span class="comment">// Total de consultas: 1247</span>
<span class="comment">// Itens em cache: 234</span></div>
      </div>

      <h3>Invalidacao Manual</h3>
      <div class="example">
        <h4>Limpar cache quando necessario</h4>
        <div class="code-block"><span class="comment">// Invalidar todo o cache</span>
cache.<span class="function">invalidateAll</span>();

<span class="comment">// Invalidar queries especificas (futuro)</span>
<span class="comment">// cache.invalidatePattern('SELECT * FROM usuarios WHERE %');</span></div>
        <p>Use invalidateAll() quando precisar forcar uma atualizacao completa dos dados em cache.</p>
      </div>
    </div>

    <div class="section">
      <h2>Configuracao Avancada</h2>

      <h3>Opcoes do Construtor</h3>
      <div class="code-block"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="function">SmartCache</span>(db, {
  <span class="comment">// Numero maximo de itens em cache</span>
  maxItems: <span class="string">1000</span>,

  <span class="comment">// Tempo de vida em milissegundos</span>
  ttlMs: <span class="string">5 * 60 * 1000</span>, <span class="comment">// 5 minutos</span>

  <span class="comment">// Estrategia de cache</span>
  strategy: <span class="string">'cache-first'</span>, <span class="comment">// 'cache-first' | 'network-first' | 'stale-while-revalidate'</span>

  <span class="comment">// Habilitar triggers para invalidacao fina (opcional)</span>
  enableTriggers: <span class="keyword">false</span>,

  <span class="comment">// Tabelas para monitorar com triggers (se enableTriggers = true)</span>
  trackedTables: [<span class="string">'usuarios'</span>, <span class="string">'pedidos'</span>]
});</div>

      <h3>Adaptadores Disponiveis</h3>
      <p>O smart-cache-sqlite suporta diferentes adaptadores para SQLite:</p>
      <ul>
        <li><strong>BetterSqliteAdapter</strong>: Para better-sqlite3 (sincrono, mais rapido)</li>
        <li><strong>Sqlite3AsyncAdapter</strong>: Para sqlite3 (assincrono, mais compatibilidade)</li>
        <li><strong>ReactNativeQuickAdapter</strong>: Para React Native</li>
      </ul>
    </div>

    <div class="section">
      <h2>Melhores Praticas</h2>

      <div class="highlight">
        <h4>1. Escolha a estrategia certa</h4>
        <p>Use Cache-First para dados estaticos, Network-First para dados criticos, e Stale-While-Revalidate para melhor experiencia do usuario.</p>
      </div>

      <div class="highlight">
        <h4>2. Configure TTL apropriado</h4>
        <p>Defina tempos de vida que balanceiem performance com atualidade dos dados. Dados muito estaticos podem ter TTL maior.</p>
      </div>

      <div class="highlight">
        <h4>3. Monitore a performance</h4>
        <p>Use o metodo stats() regularmente para acompanhar hit rates e ajustar configuracoes conforme necessario.</p>
      </div>

      <div class="highlight">
        <h4>4. Considere triggers para alta frequencia</h4>
        <p>Para bancos com muitas atualizacoes, considere habilitar triggers para invalidacao mais precisa por tabela.</p>
      </div>
    </div>

    <div class="section">
      <h2>Teste Interativo</h2>
      <p>Experimente o smart-cache-sqlite funcionando em tempo real. Esta é uma demonstração simulada que mostra como o cache se comporta com diferentes estratégias:</p>

      <div class="note">
        <p><strong>Nota:</strong> Esta demo usa dados simulados pois está hospedada no GitHub Pages (apenas arquivos estáticos). Para uma experiência completa com banco de dados real, execute localmente com <code>npm run demo</code>.</p>
      </div>

      <div style="display: flex; gap: 15px; align-items: center; margin: 20px 0; flex-wrap: wrap;">
        <select id="strategy" style="padding: 10px; border: 1px solid #d1d5db; border-radius: 6px;">
          <option value="cache-first">Cache-First</option>
          <option value="network-first">Network-First</option>
          <option value="stale-while-revalidate">Stale-While-Revalidate</option>
        </select>
        <button class="btn" onclick="buscarClientes()">Buscar Clientes</button>
        <button class="btn secondary" onclick="inserirCliente()">Inserir Cliente</button>
        <button class="btn secondary" onclick="limparCache()">Limpar Cache</button>
      </div>

      <div id="resultado" style="display: none; background: #f8fafc; border-radius: 8px; padding: 20px; margin: 20px 0; border-left: 4px solid #10b981;"></div>

      <div id="tabelaClientes" style="display: none; margin: 20px 0;">
        <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
          <thead>
            <tr style="background: #f8fafc;">
              <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e5e7eb; font-weight: 600;">ID</th>
              <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e5e7eb; font-weight: 600;">Nome</th>
              <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e5e7eb; font-weight: 600;">Cidade</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
        <div style="background: white; padding: 15px; border-radius: 8px; border: 1px solid #e5e7eb; text-align: center;">
          <div style="font-size: 24px; font-weight: bold; color: #1f2937;" id="cacheItems">0</div>
          <div style="font-size: 12px; color: #6b7280; text-transform: uppercase;">Itens no Cache</div>
        </div>
        <div style="background: white; padding: 15px; border-radius: 8px; border: 1px solid #e5e7eb; text-align: center;">
          <div style="font-size: 24px; font-weight: bold; color: #1f2937;" id="hitRate">0%</div>
          <div style="font-size: 12px; color: #6b7280; text-transform: uppercase;">Taxa de Acerto</div>
        </div>
        <div style="background: white; padding: 15px; border-radius: 8px; border: 1px solid #e5e7eb; text-align: center;">
          <div style="font-size: 24px; font-weight: bold; color: #1f2937;" id="totalQueries">0</div>
          <div style="font-size: 12px; color: #6b7280; text-transform: uppercase;">Total de Consultas</div>
        </div>
      </div>

      <div style="background: #1f2937; color: #e5e7eb; padding: 15px; border-radius: 8px; font-family: 'Monaco', 'Menlo', monospace; font-size: 13px; max-height: 150px; overflow-y: auto; margin-top: 20px;">
        <div style="font-size: 12px; color: #6b7280; margin-bottom: 10px;">LOG DE OPERACOES:</div>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <script>
    // Dados simulados para a demo (já que estamos no GitHub Pages sem servidor)
    let mockClientes = [
      { id: 1, nome: 'João Silva', cidade: 'Marília' },
      { id: 2, nome: 'Maria Santos', cidade: 'Marília' },
      { id: 3, nome: 'Pedro Oliveira', cidade: 'Marília' },
      { id: 4, nome: 'Ana Costa', cidade: 'São Paulo' },
      { id: 5, nome: 'Carlos Lima', cidade: 'Rio de Janeiro' }
    ];

    let mockStats = {
      totalItems: 0,
      hitRate: 0,
      totalQueries: 0
    };

    let queryCount = 0;
    let cacheHits = 0;
    let nextId = 6;

    let logEntries = [];

    // Função mock para simular busca de clientes
    async function mockFetchClientes(cidade, strategy) {
      queryCount++;
      const start = Date.now();

      // Simular delay de rede/banco
      await new Promise(resolve => setTimeout(resolve, Math.random() * 200 + 100));

      const clientesFiltrados = mockClientes.filter(c => c.cidade === cidade);

      // Simular comportamento do cache baseado na estratégia
      let fromCache = false;
      let revalidated = false;

      if (strategy === 'cache-first') {
        fromCache = Math.random() > 0.3; // 70% chance de cache hit
        if (fromCache) cacheHits++;
      } else if (strategy === 'network-first') {
        fromCache = false; // Sempre busca no banco
      } else if (strategy === 'stale-while-revalidate') {
        fromCache = Math.random() > 0.2; // 80% chance de cache hit
        if (fromCache) {
          revalidated = Math.random() > 0.5; // 50% chance de revalidação
        }
        if (fromCache) cacheHits++;
      }

      mockStats.totalQueries = queryCount;
      mockStats.hitRate = cacheHits / queryCount;
      mockStats.totalItems = Math.floor(Math.random() * 50) + 10; // Simular itens no cache

      return {
        rows: clientesFiltrados,
        fromCache,
        revalidated
      };
    }

    // Função mock para inserir cliente
    async function mockInsertCliente(nome, cidade) {
      await new Promise(resolve => setTimeout(resolve, Math.random() * 150 + 50));

      const novoCliente = { id: nextId++, nome, cidade };
      mockClientes.push(novoCliente);

      // Simular invalidação de cache
      cacheHits = Math.floor(cacheHits * 0.7); // Reduzir hits após invalidação

      return { id: novoCliente.id };
    }

    // Função mock para limpar cache
    async function mockInvalidateCache() {
      await new Promise(resolve => setTimeout(resolve, 100));
      cacheHits = 0;
      mockStats.totalItems = 0;
    }

    async function buscarClientes() {
      const strategy = document.getElementById('strategy').value;
      const resultado = document.getElementById('resultado');
      const tabela = document.getElementById('tabelaClientes');

      resultado.style.display = 'block';
      resultado.innerHTML = '<div style="color: #6b7280;">Buscando clientes...</div>';

      try {
        const start = Date.now();
        const data = await mockFetchClientes('Marília', strategy);
        const duration = Date.now() - start;

        let statusText = '';
        let borderColor = '#10b981';

        if (data.fromCache) {
          statusText = `Servido do cache em ${duration}ms`;
        } else {
          statusText = `Buscado do banco em ${duration}ms`;
          borderColor = '#3b82f6';
        }

        if (data.revalidated) {
          statusText += ' (revalidado em background)';
        }

        resultado.style.borderLeftColor = borderColor;
        resultado.innerHTML = `
          <div style="margin-bottom: 10px;"><strong>Resultado:</strong> ${statusText}</div>
          <div><strong>Registros encontrados:</strong> ${data.rows.length}</div>
        `;

        const tbody = tabela.querySelector('tbody');
        tbody.innerHTML = '';
        data.rows.forEach(row => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${row.id}</td><td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${row.nome}</td><td style="padding: 12px; border-bottom: 1px solid #e5e7eb;">${row.cidade}</td>`;
          tbody.appendChild(tr);
        });
        tabela.style.display = 'block';

        addLog(`${strategy}: ${data.rows.length} clientes encontrados (${data.fromCache ? 'CACHE' : 'BANCO'})`);
        atualizarStats();
      } catch (error) {
        resultado.style.borderLeftColor = '#ef4444';
        resultado.innerHTML = `<div style="color: #dc2626;"><strong>Erro:</strong> ${error.message}</div>`;
        addLog(`Erro: ${error.message}`);
      }
    }

    async function inserirCliente() {
      const nome = prompt('Nome do cliente:', 'Cliente Exemplo');
      const cidade = prompt('Cidade:', 'Marília');

      if (!nome || !cidade) return;

      try {
        const data = await mockInsertCliente(nome, cidade);

        document.getElementById('resultado').innerHTML = '<div style="color: #059669;"><strong>Sucesso:</strong> Cliente inserido com ID ' + data.id + '</div>';
        document.getElementById('resultado').style.display = 'block';

        addLog(`Cliente inserido: ${nome} (${cidade}) - ID: ${data.id}`);
        atualizarStats();
      } catch (error) {
        addLog(`Erro ao inserir: ${error.message}`);
      }
    }

    async function limparCache() {
      try {
        await mockInvalidateCache();
        addLog('Cache limpo manualmente');
        document.getElementById('resultado').innerHTML = '<div style="color: #059669;"><strong>Sucesso:</strong> Cache limpo</div>';
        document.getElementById('resultado').style.display = 'block';
        atualizarStats();
      } catch (error) {
        addLog(`Erro ao limpar cache: ${error.message}`);
      }
    }

    async function atualizarStats() {
      try {
        // Usar dados mockados em vez de fetch
        document.getElementById('cacheItems').textContent = mockStats.totalItems || 0;
        document.getElementById('hitRate').textContent = mockStats.hitRate ? Math.round(mockStats.hitRate * 100) + '%' : '0%';
        document.getElementById('totalQueries').textContent = mockStats.totalQueries || 0;
      } catch (error) {
        console.error('Erro ao atualizar stats:', error);
      }
    }

    function addLog(message) {
      const now = new Date().toLocaleTimeString();
      logEntries.unshift(`[${now}] ${message}`);
      if (logEntries.length > 10) logEntries.pop();

      const logDiv = document.getElementById('log');
      logDiv.innerHTML = logEntries.map(entry => `<div style="margin: 3px 0; padding: 3px; background: rgba(255,255,255,0.05); border-radius: 3px;">${entry}</div>`).join('');
    }

    // Inicialização
    atualizarStats();
    addLog('Demo inicializado - smart-cache-sqlite');
    setInterval(atualizarStats, 3000);
  </script>
</body>
</html>
